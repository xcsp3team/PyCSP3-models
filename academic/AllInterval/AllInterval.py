"""
Given the twelve standard pitch-classes (c, c#, d, ...), represented by numbers 0,1,...,11,
find a series in which each pitch-class occurs exactly once and in which the musical intervals
between neighboring notes cover the full set of intervals from the minor second (1 semitone) to the major seventh (11 semitones).
That is, for each of the intervals, there is a pair of neighboring pitch-classes in the series, between which this interval appears.
Elliott Carter often bases his all-interval sets on the list generated by Bauer-Mendelberg and Ferentz and uses them as a "tonic" sonority.

![Carter All-Interval](https://pycsp.org/assets/notebooks/figures/Carter_all-interval_sets.png)

The problem of finding such a series can be easily formulated as an instance of a more general arithmetic problem.
Given a positive integer n, find a sequence x of n numbers such that:
  - x is a permutation of {0,1,...,n-1};
  - the interval sequence y = <|x1-x0|, |x2-x1|, ...>  is a permutation of {1,2,...,n-1}.
A sequence satisfying these conditions is called an all-interval series of order n;
the problem of finding such a series is the all-interval series problem of order n.

### Example
  For n=8, a solution is:
  ```
    1 7 0 5 4 2 6 3
  ```

## Data
  a number n, the size of the sequence

## Model
  There are two variants:
     - a main variant;
     - a variant 'aux' involving auxiliary variables.

  You can also find a step-by-step modeling process in this [Jupyter notebook](http://pycsp.org/documentation/models/CSP/AllInterval/).

  constraints: AllDifferent

## Execution
  - python AllInterval.py -data=number [-solve]
  - python AllInterval.py -data=number -variant=aux [-solve]

## Tags
  academic, notebook
"""

from pycsp3 import *

n = data or 8

# x[i] is the ith note of the series
x = VarArray(size=n, dom=range(n))

if not variant():
    satisfy(
        # notes must occur once, and so form a permutation
        AllDifferent(x),

        # intervals between neighbouring notes must form a permutation
        AllDifferent(abs(x[i + 1] - x[i]) for i in range(n - 1)),

        # tag(symmetry-breaking)
        x[0] < x[n - 1]
    )

elif variant("aux"):
    # y[i] is the distance between x[i] and x[i+1]
    y = VarArray(size=n - 1, dom=range(1, n))

    satisfy(
        # notes must occur once, and so form a permutation
        AllDifferent(x),

        # intervals between neighbouring notes must form a permutation
        AllDifferent(y),

        # computing distances
        [y[i] == abs(x[i + 1] - x[i]) for i in range(n - 1)],

        # tag(symmetry-breaking)
        [
            x[0] < x[n - 1],
            y[0] < y[1]
        ]
    )
